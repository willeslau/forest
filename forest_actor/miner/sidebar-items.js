initSidebarItems({"constant":[["ADDRESSED_PARTITIONS_MAX","The maximum number of partitions that may be required to be loaded in a single invocation. This limits the number of simultaneous fault, recovery, or sector-extension declarations. With 48 deadlines (half-hour), 200 partitions per declaration permits loading a full EiB of 32GiB sectors with 1 message per epoch within a single half-hour deadline. A miner can of course submit more messages."],["ADDRESSED_SECTORS_MAX","The maximum number of sector infos that may be required to be loaded in a single invocation."],["CHAIN_FINALITY","Epochs after which chain state is final with overwhelming probability (hence the likelihood of two fork of this size is negligible) This is a conservative value that is chosen via simulations of all known attacks."],["CONSENSUS_FAULT_INELIGIBILITY_DURATION","Number of epochs after a consensus fault for which a miner is ineligible for permissioned actor methods and winning block elections."],["CONSENSUS_FAULT_REPORTER_DEFAULT_SHARE",""],["CONTINUED_FAULT_PROJECTION_PERIOD",""],["CRON_EVENT_PROCESS_EARLY_TERMINATIONS",""],["CRON_EVENT_PROVING_DEADLINE",""],["CRON_EVENT_WORKER_KEY_CHANGE",""],["DEAL_LIMIT_DENOMINATOR","Ratio of sector size to maximum deals per sector. The maximum number of deals is the sector size divided by this number (2^27) which limits 32GiB sectors to 256 deals and 64GiB sectors to 512"],["DELCARATIONS_MAX","Maximum number of unique “declarations” in batch operations."],["EXPIRED_PRE_COMMIT_CLEAN_UP_DELAY","The delay between pre commit expiration and clean up from state. This enforces that expired pre-commits stay in state for a period of time creating a grace period during which a late-running aggregated prove-commit can still prove its non-expired precommits without resubmitting a message"],["FAULT_DECLARATION_CUTOFF","Minimum period before a deadline’s challenge window opens that a fault must be declared for that deadline. This lookback must not be less than WPoStChallengeLookback lest a malicious miner be able to selectively declare faults after learning the challenge value."],["FAULT_MAX_AGE","The maximum age of a fault before the sector is terminated."],["INITIAL_PLEDGE_PROJECTION_PERIOD",""],["MAX_AGGREGATED_PROOF_SIZE","Maximum total aggregated proof size."],["MAX_AGGREGATED_SECTORS","Maximum amount of sectors that can be aggregated."],["MAX_CONTROL_ADDRESSES","Maximum number of control addresses a miner may register."],["MAX_MULTIADDR_DATA","MaxMultiaddrData is the maximum amount of data that can be stored in multiaddrs."],["MAX_PARTITIONS_PER_DEADLINE","Maximum number of partitions that will be assigned to a deadline. For a minimum storage of upto 1Eib, we need 300 partitions per deadline. 48 * 32GiB * 2349 * 300 = 1.00808144 EiB So, to support upto 10Eib storage, we set this to 3000."],["MAX_PEER_ID_LENGTH","MaxPeerIDLength is the maximum length allowed for any on-chain peer ID. Most Peer IDs are expected to be less than 50 bytes."],["MAX_PRE_COMMIT_RANDOMNESS_LOOKBACK",""],["MAX_PROVE_COMMIT_SIZE_V4",""],["MAX_PROVE_COMMIT_SIZE_V5",""],["MAX_SECTOR_EXPIRATION_EXTENSION","Maximum number of epochs past the current epoch a sector may be set to expire. The actual maximum extension will be the minimum of CurrEpoch + MaximumSectorExpirationExtension and sector.ActivationEpoch+sealProof.SectorMaximumLifetime()"],["MIN_AGGREGATED_SECTORS","Minimum amount of sectors that can be aggregated."],["MIN_SECTOR_EXPIRATION","Minimum number of epochs past the current epoch a sector may be set to expire."],["NEW_SECTORS_PER_PERIOD_MAX","The maximum number of new sectors that may be staged by a miner during a single proving period."],["PRE_COMMIT_CHALLENGE_DELAY","Number of epochs between publishing the precommit and when the challenge for interactive PoRep is drawn used to ensure it is not predictable by miner."],["PRE_COMMIT_DEPOSIT_PROJECTION_PERIOD",""],["PRE_COMMIT_SECTOR_BATCH_MAX_SIZE","The maximum number of sector pre-commitments in a single batch. 32 sectors per epoch would support a single miner onboarding 1EiB of 32GiB sectors in 1 year."],["REWARD_VESTING_SPEC",""],["SEALED_CID_PREFIX","Prefix for sealed sector CIDs (CommR)."],["SECTORS_MAX","The maximum number of sectors that a miner can have simultaneously active. This also bounds the number of faults that can be declared, etc."],["TERMINATION_LIFETIME_CAP",""],["WORKER_KEY_CHANGE_DELAY","Staging period for a miner worker key change. Finality is a harsh delay for a miner who has lost their worker key, as the miner will miss Window PoSts until it can be changed. It’s the only safe value, though. We may implement a mitigation mechanism such as a second key or allowing the owner account to submit PoSts while a key change is pending."],["WPOST_CHALLENGE_LOOKBACK","Lookback from the deadline’s challenge window opening from which to sample chain randomness for the challenge seed. This lookback exists so that deadline windows can be non-overlapping (which make the programming simpler) but without making the miner wait for chain stability before being able to start on PoSt computation. The challenge is available this many epochs before the window is actually open to receiving a PoSt."],["WPOST_CHALLENGE_WINDOW","The duration of a deadline’s challenge window, the period before a deadline when the challenge is available."],["WPOST_DISPUTE_WINDOW",""],["WPOST_MAX_CHAIN_COMMIT_AGE","The maximum distance back that a valid Window PoSt must commit to the current chain."],["WPOST_PERIOD_DEADLINES","The number of non-overlapping PoSt deadlines in each proving period."],["WPOST_PROVING_PERIOD","The period over which all a miner’s active sectors will be challenged."]],"enum":[["CollisionPolicy",""],["Method","Storage Miner actor methods available"]],"fn":[["aggregate_network_fee",""],["assign_deadlines",""],["can_extend_seal_proof_type","Checks whether a seal proof type is supported for new miners and sectors."],["can_pre_commit_seal_proof","List of proof types which can be used when creating new miner actors"],["consensus_fault_penalty",""],["deadline_available_for_compaction",""],["deadline_available_for_optimistic_post_dispute",""],["deadline_is_mutable","Returns true if the deadline at the given index is currently mutable."],["expected_reward_for_power","The projected block reward a sector would earn over some period. Also known as “BR(t)”. BR(t) = ProjectedRewardFraction(t) * SectorQualityAdjustedPower ProjectedRewardFraction(t) is the sum of estimated reward over estimated total power over all epochs in the projection period [t t+projectionDuration]"],["initial_pledge_for_power","Computes the pledge requirement for committing new quality-adjusted power to the network, given the current network total and baseline power, per-epoch  reward, and circulating token supply. The pledge comprises two parts:"],["load_partitions_sectors_max","The maximum number of partitions that may be required to be loaded in a single invocation, when all the sector infos for the partitions will be loaded."],["locked_reward_from_reward","Returns the amount of a reward to vest, and the vesting schedule, for a reward amount."],["max_prove_commit_duration","Maximum duration to allow for the sealing process for seal algorithms. Dependent on algorithm and sector size"],["new_deadline_info",""],["new_deadline_info_from_offset_and_epoch",""],["pledge_penalty_for_continued_fault","The penalty for a sector continuing faulty for another proving period. It is a projection of the expected reward earned by the sector. Also known as “FF(t)”"],["pledge_penalty_for_invalid_windowpost",""],["pledge_penalty_for_termination","Penalty to locked pledge collateral for the termination of a sector before scheduled expiry. SectorAge is the time between the sector’s activation and termination."],["pledge_penalty_for_termination_lower_bound","This is the SP(t) penalty for a newly faulty sector that has not been declared. SP(t) = UndeclaredFaultFactor * BR(t)"],["pre_commit_deposit_for_power","Computes the PreCommit deposit given sector qa weight and current network conditions. PreCommit Deposit = BR(PreCommitDepositProjectionPeriod)"],["qa_power_for_sector","Returns the quality-adjusted power for a sector."],["qa_power_for_weight","Returns the power for a sector size and weight."],["quant_spec_for_deadline",""],["reward_for_consensus_slash_report",""],["reward_for_disputed_window_post",""],["seal_proof_sector_maximum_lifetime","Maximum duration to allow for the sealing process for seal algorithms. Dependent on algorithm and sector size"],["sector_deals_max","Determine maximum number of deal miner’s sector can hold"]],"struct":[["Actor","Miner Actor here in order to update the Power Actor to v3."],["AdvanceDeadlineResult",""],["ApplyRewardParams",""],["BASE_PENALTY_FOR_DISPUTED_WINDOW_POST","Base penalty for a successful disputed window post proof."],["BASE_REWARD_FOR_DISPUTED_WINDOW_POST","Base reward for successfully disputing a window posts proofs."],["BitFieldQueue","Wrapper for working with an AMT[ChainEpoch]*Bitfield functioning as a queue, bucketed by epoch. Keys in the queue are quantized (upwards), modulo some offset, to reduce the cardinality of keys."],["ChangeMultiaddrsParams",""],["ChangePeerIDParams",""],["ChangeWorkerAddressParams",""],["CheckSectorProvenParams",""],["CompactPartitionsParams",""],["CompactSectorNumbersParams",""],["ConfirmSectorProofsParams",""],["CronEventPayload",""],["Deadline","Deadline holds the state for all sectors due at a specific deadline."],["DeadlineSectorMap","Maps deadlines to partition maps."],["Deadlines","Deadlines contains Deadline objects, describing the sectors due at the given deadline and their state (faulty, terminated, recovering, etc.)."],["DeclareFaultsParams",""],["DeclareFaultsRecoveredParams",""],["DisputeInfo",""],["DisputeWindowedPoStParams",""],["ExpirationExtension",""],["ExpirationQueue","A queue of expiration sets by epoch, representing the on-time or early termination epoch for a collection of sectors. Wraps an AMT[ChainEpoch]*ExpirationSet. Keys in the queue are quantized (upwards), modulo some offset, to reduce the cardinality of keys."],["ExpirationSet","ExpirationSet is a collection of sector numbers that are expiring, either due to expected “on-time” expiration at the end of their life, or unexpected “early” termination due to being faulty for too long consecutively. Note that there is not a direct correspondence between on-time sectors and active power; a sector may be faulty but expiring on-time if it faults just prior to expected termination. Early sectors are always faulty, and active power always represents on-time sectors."],["ExtendSectorExpirationParams",""],["Fault",""],["FaultDeclaration",""],["GetControlAddressesReturn",""],["MinerConstructorParams","Storage miner actor constructor params are defined here so the power actor can send them to the init actor to instantiate miners."],["MinerInfo","Static information about miner"],["Partition",""],["PartitionKey",""],["PartitionSectorMap","Maps partitions to sector bitfields."],["PoStPartition",""],["PoStResult",""],["PowerPair",""],["PreCommitSectorBatchParams",""],["ProveCommitAggregateParams",""],["ProveCommitSectorParams",""],["RecoveryDeclaration",""],["ReportConsensusFaultParams",""],["SectorOnChainInfo","Information stored on-chain for a proven sector."],["SectorPreCommitInfo",""],["SectorPreCommitOnChainInfo","Information stored on-chain for a pre-committed sector."],["Sectors",""],["State","Balance of Miner Actor should be greater than or equal to the sum of PreCommitDeposits and LockedFunds. It is possible for balance to fall below the sum of PCD, LF and InitialPledgeRequirements, and this is a bad state (IP Debt) that limits a miner actor’s behavior (i.e. no balance withdrawals) Excess balance as computed by st.GetAvailableBalance will be withdrawable or usable for pre-commit deposit or pledge lock-up."],["SubmitWindowedPoStParams","Information submitted by a miner to provide a Window PoSt."],["TerminateSectorsParams",""],["TerminateSectorsReturn",""],["TerminationDeclaration",""],["TerminationResult",""],["VestSpec","Specification for a linear vesting schedule."],["VestingFund",""],["VestingFunds","Represents the vesting table state for the miner. It is a slice of (VestingEpoch, VestingAmount). The slice will always be sorted by the VestingEpoch."],["WindowedPoSt",""],["WithdrawBalanceParams",""],["WorkerKeyChange",""]],"type":[["CronEvent",""],["PreCommitSectorParams",""]]});